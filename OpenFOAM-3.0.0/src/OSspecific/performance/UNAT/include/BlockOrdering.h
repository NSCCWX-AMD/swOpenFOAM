/*#########################
	将数据结构进行到底

	MLB means Multilevel_Blocking
#########################*/

#ifndef BLOCKORDERING_H
#define BLOCKORDERING_H

#include "stdio.h"
#include "metis.h"
#include "swMacro.h"
#include "extensibleLabelArray.h"
#include "timer.h"

#define DEBUG_MLB 0

LABEL max_label(LABEL* array, size_t length);

LABEL min_label(LABEL* array, size_t length);

/*
 * format for graph printing
 */
#define GRAPH_FMT(graph) \
"GRAPH %s \n \
{ \n\
	owner(%p): max %d, min %d, \n\
	neighbor(%p): max %d, min %d, \n\
	cellWeights(%p): max %d, min %d, \n\
	edgeWeights(%p): max %d, min %d, \n\
	cellNum = %d \n\
	edgeNum = %d \n\
}\n", \
#graph, \
(graph).owner, \
max_label((graph).owner, (graph).edgeNum), \
min_label((graph).owner, (graph).edgeNum),\
(graph).neighbor, \
max_label((graph).neighbor, (graph).edgeNum), \
min_label((graph).neighbor, (graph).edgeNum),\
(graph).cellWeights, \
max_label((graph).cellWeights, (graph).cellNum), \
min_label((graph).cellWeights, (graph).cellNum),\
(graph).edgeWeights, \
max_label((graph).edgeWeights, (graph).edgeNum), \
min_label((graph).edgeWeights, (graph).edgeNum),\
(graph).cellNum, \
(graph).edgeNum

#define MLB_postEdge( order, array, length, size) \
{ \
	char* tmp_array = (char*) malloc( (size) * (length) ); \
	memcpy(tmp_array, array, (size)*(length) ); \
	size_t iPostEA; \
	for( iPostEA = 0; iPostEA < (length); iPostEA++) \
	{ \
		char* destPtr = \
			&( ( (char*)array ) \
						[ ( abs( (order)[iPostEA] ) - 1 )*(size) ] \
			 ); \
		char* srcPtr = &tmp_array[iPostEA*(size)]; \
		memcpy(destPtr, srcPtr, size);\
	} \
	free(tmp_array); \
}

#ifdef __cplusplus
extern "C"
{
#endif

#define LABEL swInt
#define SCALAR swFloat

#define CERR(...) \
{ \
	printf("***Error: at "); \
	printf("%s",__FILE__); \
	printf("+%d:",__LINE__); \
	printf("\n\t"); \
	printf("in function \"%s\": ", __FUNCTION__); \
	printf(__VA_ARGS__); \
}


#define forprt(array, n) \
{\
	printf(#array);\
	printf(":{");\
	LABEL i;\
	for(i=0; i<n; i++)\
	  printf(" %d", (LABEL)(array[i]));\
	printf("}\n");\
}

#define startTime() \
	LABEL printTime_start = getSystemTime()

#define printTime(tag) \
{ \
	printf("=======================\n");\
	printf(#tag);\
	printf(": %fs\n", getSystemTime()-printTime_start); \
	printTime_start = getSystemTime(); \
	printf("=======================\n");\
}


typedef struct struct_MLB_graph
{
	LABEL* owner;	// cell owns the edge starts from "0" 
 	LABEL* neighbor;	// cell adjoins to the edge
 	LABEL* cellWeights;
 	LABEL* edgeWeights;
 	LABEL cellNum;    // number of the cells
 	LABEL edgeNum;	// number of the edges
} MLB_graph;

void MLB_Multilevel_ordering
(
 MLB_graph graph,
 LABEL levels,		// number of levels
 LABEL* blockNums,	// number of blocks for each level
 // blockStarts: Three-LABEL element array.
 // The first is block-row index, and second block-column.
 // The third is the start edge index for each block.
 // Only upper triagle stored.
 LABEL* blockStarts, 
 LABEL* cellStarts, // start cell index for each block
 // postCellOrder & postEdgeOrder:
 // Index mirror from the old order to the new one.
 // The position of the element corresponds to the old order,
 // and the element value the new one.
 LABEL* postCellOrder,
 LABEL* postEdgeOrder
);

void MLB_ordering
(
 MLB_graph graph,
 LABEL blockNum,	// number of blocks for each level
 // postCellOrder:
 // Index mirror from the old order to the new one.
 // The position of the element corresponds to the old order,
 // and the element value the new one.
 LABEL* postCellOrder,	// starts from zero
 LABEL* cellStarts	// cells in each block
);

// reorder the float datas arrays with the index mirror
// generated by multi_block_ordering
void MLB_postSCALAR
(
 LABEL* postOrder,
 SCALAR*	dataArray,
 LABEL length,
 LABEL dim
);

void MLB_postLABEL
(
 LABEL* postOrder,
 LABEL*	dataArray,
 LABEL length,
 LABEL dim
);

// reorder the integer datas arrays with the index mirror
// generated by multi_block_ordering
void MLB_metis_decompose
(
 idx_t cellNum,
 idx_t edgeNum,
 idx_t* adj,
 idx_t* neighbor,
 idx_t* cellWeight,
 idx_t* edgeWeight,
 idx_t blockNum,
 idx_t* options,
 idx_t* edgeCut,
 idx_t* blockCells,
 char* method
);

void MLB_generateCellID
(
 LABEL* owner,
 LABEL* neighbor,
 LABEL* cellID,
 LABEL cellNum,
 LABEL edgeNum
);

void MLB_offsetEdges
(
 LABEL* owner,
 LABEL* neighbor,
 LABEL* cellID,
 LABEL* ownerNorm,
 LABEL* neighborNorm,
 LABEL cellNum,
 LABEL edgeNum
);

void MLB_constructMetisCSR
(
 LABEL* owner,
 LABEL* neighbor,
 LABEL* edegWeight,
 LABEL* xadj,
 LABEL* adjncy,
 LABEL* edge_wgt,
 LABEL cellNum,
 LABEL edgeNum
);

LABEL MLB_find(LABEL id, LABEL* array, LABEL num);

void MLB_quickSort(int *arr, int elements); 

#ifdef __cplusplus
}
#endif

#endif // BLOCKORDERNG_H
