#include "BlockOrdering.h"
#include "extensibleLabelArray.h"

extern void paraStdOut( const char* , ...);

LABEL max_label(LABEL* array, size_t length)
{
	size_t i;
	double max = array[0];
	for(i = 0; i<length; i++)
		max = (max > array[i]) ? max : array[i];
	return max;
}

LABEL min_label(LABEL* array, size_t length) 
{
	size_t i;
	LABEL min = array[0]; 
	for(i = 0; i<length; i++)
		min = (min < array[i]) ? min : array[i];
	return min;
}

// reorder the float datas arrays with the index mirror
// generated by multi_block_ordering
void MLB_postSCALAR
(
 LABEL* postOrder,
 SCALAR*	dataArray,
 LABEL length,
 LABEL dim
)
{
	SCALAR* tmpArray = (SCALAR*) malloc(sizeof(SCALAR)*length*dim);
	LABEL i,j;
	for(i=0; i<length; i++)
	for(j=0; j<dim; j++)
		tmpArray[abs(postOrder[i])*dim+j] = dataArray[i*dim+j];
	memcpy(dataArray, tmpArray, sizeof(SCALAR)*length*dim);

	free(tmpArray);
}

// reorder the integer datas arrays with the index mirror
// generated by multi_block_ordering
void MLB_postLABEL
(
 LABEL* postOrder,
 LABEL*	dataArray,
 LABEL length,
 LABEL dim
)
{
	LABEL* tmpArray = (LABEL*) malloc(sizeof(LABEL)*length*dim);
	LABEL i,j;
	for(i=0; i<length; i++)
	for(j=0; j<dim; j++)
		tmpArray[abs(postOrder[i])*dim+j] = dataArray[i*dim+j];
	memcpy(dataArray, tmpArray, sizeof(LABEL)*length*dim);

	free(tmpArray);
}


void MLB_metis_decompose
(
 idx_t cellNum,
 idx_t edgeNum,
 idx_t* xadj,
 idx_t* adjncy,
 idx_t* cellWeight,
 idx_t* edgeWeight,
 idx_t blockNum,
 idx_t* options,
 idx_t* edgeCut,
 idx_t* blockCells,
 char* method
)
{
	if(sizeof(real_t) != sizeof(SCALAR))
	{
		CERR("size of real_t is %d, but size of SCALAR is %d\n", 
					sizeof(real_t), sizeof(SCALAR));	
		exit(-1);
	}

	idx_t ncon = 1;
	real_t imbalan = 1.05;
	// decompose by metis
	if(method == "recursive")
	{
		METIS_PartGraphRecursive
		(
		 &cellNum,	// number of cells
		 &ncon,	// num balancing constraints
		 xadj,	// compressed row indice
		 adjncy,	// column indice
		 cellWeight,	// cell weights 
		 NULL,	// number of cells for computing total communication volumn
		 edgeWeight,	// edge weights
		 &blockNum,	// block number
		 NULL,//blockWeight,	// block weights
		 &imbalan,	// block imbalance
		 options,	// options
		 edgeCut,	// total edge cut	
		 blockCells	// decompose result
		);
	}
	else
	{
		METIS_PartGraphKway
		(
		 &cellNum,	// number of cells
		 &ncon,	// number of edges
		 xadj,	// compressed row indice
		 adjncy,	// column indice
		 cellWeight,	// cell weights 
		 NULL,	// number of cells for computing total communication volumn
		 edgeWeight,	// edge weights
		 &blockNum,	// block number
		 NULL,//blockWeight,	// block weights
		 &imbalan,	// block imbalance
		 options,	// options
		 edgeCut,	// total edge cut	
		 blockCells	// decompose result
		);
	}
}

void MLB_generateCellID
(
 LABEL* owner,
 LABEL* neighbor,
 LABEL* cellID,
 LABEL cellNum,
 LABEL edgeNum
)
{
	LABEL icell, iedge;
    //==============multi level loop version==============
	//LABEL minid = -1;
	//for(icell=0; icell<cellNum; icell++)
	//{
	//	LABEL nextid = -1;
	//	for(iedge=0; iedge<edgeNum; iedge++)
	//	{
	//		if( owner[iedge] > minid && (nextid == -1 
	//		    || owner[iedge] < nextid) )
	//			nextid = owner[iedge];
	//		if( neighbor[iedge] > minid && (nextid == -1 
	//		    || neighbor[iedge] < nextid) )
	//			nextid = neighbor[iedge];	  
	//	}
	//	if(minid < nextid) minid = nextid;
	//	else CERR("minid = %d, nextid = %d, No enough cells!!\n",
	//			  minid, nextid);
	//	cellID[icell] = minid;
	//}
	//for(iedge=0; iedge<edgeNum; iedge++)
	//{
	//	if( owner[iedge] > minid || neighbor[iedge] > minid )
	//		CERR("two much cells!!\n");
	//}

	//=================quick sort version==================
	LABEL* cellRepo =
		(LABEL*)malloc(sizeof(LABEL)*2*edgeNum);
	for(iedge=0; iedge<edgeNum; iedge++)
	{
		cellRepo[2*iedge]   = owner[iedge];
		cellRepo[2*iedge+1] = neighbor[iedge];
	}
	MLB_quickSort(cellRepo, 2*edgeNum);
//for(iedge=0; iedge<2*edgeNum-1; iedge++)
//{
//	if(cellRepo[iedge] > cellRepo[iedge+1])
//		paraStdOut("sort failed %dth:%d, %dth:%d\n", 
//					iedge, cellRepo[iedge], iedge+1,  cellRepo[iedge+1]);
//}

	cellID[0] = cellRepo[0];
	LABEL pickedCells = 1;
	for(iedge=1; iedge<2*edgeNum; iedge++)
	{
		if(cellRepo[iedge]!=cellRepo[iedge-1])
		{
			cellID[pickedCells] = 
				cellRepo[iedge];
			pickedCells++;
		}
	}

	/* ********************************debug************************************** *\/
	static int callNum = 0;
	static int addcellNum = 0;
	addcellNum += cellNum;
	callNum ++;
	printf("\ncallNum=%d, pickedCells=%d  cellNum=%d addcellNum=%d\n", callNum, pickedCells, cellNum, addcellNum);
	/* ********************************debug************************************** */

	// check
	if( pickedCells != cellNum )
	{
		CERR("cells in graph have no edge!");
		printf("\nthe difference: pickedCells=%d  cellNum=%d\n", pickedCells,cellNum);
		exit(-1);

	
/* ********************************debug************************************** *\/
	int cellFaceNum[cellNum], cellOwNum[cellNum], cellNeNum[cellNum];
	for (int i = 0; i < cellNum; ++i)
	{
		cellFaceNum[i] = 0;
		cellOwNum[i] = 0;
		cellNeNum[i] = 0;
	}
	for (int i = 0; i < 2*edgeNum; ++i)
	{
		//printf("i=%d  cellRepo[i]=%d\n", i,cellRepo[i]);
		cellFaceNum[cellRepo[i]] ++;
		if (i%2 == 0)cellOwNum[cellRepo[i]] ++;
		else cellNeNum[cellRepo[i]] ++;
	}

	FILE* fp;
	fp=fopen("problemBlockCell.txt","w");
	if(fp==NULL)printf("fail to open file!");
	else {
		
		//for (int i = 0; i < 2*edgeNum; ++i)
		//{
		//	fprintf(fp,"i=%d  cellRepo[i]=%d\n", i,cellRepo[i]);
		//}

		for (int i = 0; i < edgeNum; ++i)
		{
			fprintf(fp,"i=%d  owner[i]=%d  neighbor[i]=%d\n", i, owner[i], neighbor[i]);
		}

		for (int i = 0; i < cellNum; ++i)
		{
			fprintf(fp,"cellFaceNum[i]=%d, cellOwNum[i]=%d, cellNeNum[i]=%d\n",cellFaceNum[i], cellOwNum[i], cellNeNum[i]);
		}
	}
	fclose(fp);
/* ********************************debug************************************** */

	} 
	free(cellRepo);
}

void MLB_offsetEdges
(
 LABEL* owner,
 LABEL* neighbor,
 LABEL* cellID,
 LABEL* ownerNorm,
 LABEL* neighborNorm,
 LABEL cellNum,
 LABEL edgeNum
)
{
	LABEL iedge;
	for(iedge=0; iedge<edgeNum; iedge++)
	{
		ownerNorm[iedge] = 
			MLB_find(owner[iedge], cellID, cellNum);
		neighborNorm[iedge] = 
			MLB_find(neighbor[iedge], cellID, cellNum);
	}
}

void MLB_constructMetisCSR
(
 LABEL* owner,
 LABEL* neighbor,
 LABEL* edgeWeight,
 LABEL* xadj,
 LABEL* adjncy,
 LABEL* edge_wgt,
 LABEL cellNum,
 LABEL edgeNum
)
{
	ExtensibleLABELArray* adjncy4cells =
		(ExtensibleLABELArray*)malloc(
					cellNum*sizeof(ExtensibleLABELArray));
	ExtensibleLABELArray* edgeWgt4cells =
		(ExtensibleLABELArray*)malloc(
					cellNum*sizeof(ExtensibleLABELArray));
	LABEL icell;
	for(icell=0; icell<cellNum; icell++)
	{
		extensibleLABELArrayInit(&adjncy4cells[icell]);
		extensibleLABELArrayInit(&edgeWgt4cells[icell]);
		xadj[icell] = 0;
	}
	xadj[cellNum] = 0;

	LABEL iedge;
	for(iedge=0; iedge<edgeNum; iedge++)
	{
		extensibleLABELArrayAdd(
					&adjncy4cells[owner[iedge]],
					neighbor[iedge]
					);
		extensibleLABELArrayAdd(
					&edgeWgt4cells[owner[iedge]],
					edgeWeight[iedge]
					);
		xadj[owner[iedge]+1]++;
		extensibleLABELArrayAdd(
					&adjncy4cells[neighbor[iedge]],
					owner[iedge]
					);
		extensibleLABELArrayAdd(
					&edgeWgt4cells[neighbor[iedge]],
					edgeWeight[iedge]
					);
		xadj[neighbor[iedge]+1]++;
	}

	LABEL nedges = 0;
	for(icell=0; icell<cellNum; icell++)
	{
		memcpy( &adjncy[nedges], 
				adjncy4cells[icell].data,
				adjncy4cells[icell].size*sizeof(LABEL));
		memcpy( &edge_wgt[nedges], 
				edgeWgt4cells[icell].data,
				edgeWgt4cells[icell].size*sizeof(LABEL));
		nedges += adjncy4cells[icell].size;
		extensibleLABELArrayDestroy(&adjncy4cells[icell]);
		extensibleLABELArrayDestroy(&edgeWgt4cells[icell]);
		xadj[icell+1] += xadj[icell];
	}
	free(adjncy4cells);
	free(edgeWgt4cells);
}

LABEL MLB_find(LABEL id, LABEL* array, LABEL num)
{
	if(num < 1)
	{
	   	CERR("array has length short than 1 !!\n");
		exit(-1);
	}

	LABEL low, up, mid;
	low = 0;
	up  = num-1;
	mid = (low+up)/2;
	while(array[mid] != id)
	{
		if(low == up)
		{
			CERR("find nothing, some error!!\n");
			exit(-1);
		}
		if(array[mid] < id)
		  low = mid + 1;
		else
		  up  = mid - 1;
		mid = (low+up)/2;
	}
	return mid;
}

void MLB_quickSort(int *arr, int elements) 
{
 #define  MAX_LEVELS  300
	int  piv, beg[MAX_LEVELS], end[MAX_LEVELS], i=0, L, R, swap;
	beg[0]=0;
	end[0]=elements;
	while (i>=0) 
	{
		L=beg[i]; 
		R=end[i]-1;
		if (L<R) 
		{
			piv=arr[L];
			while (L<R)
			{
				while (arr[R]>=piv && L<R) R--;
				if (L<R) arr[L++]=arr[R];
				while (arr[L]<=piv && L<R) L++; 
				if (L<R) arr[R--]=arr[L]; 
			}
			arr[L]=piv; 
			beg[i+1]=L+1; 
			end[i+1]=end[i]; 
			end[i++]=L;
			if (end[i]-beg[i]>end[i-1]-beg[i-1]) 
			{
			    swap=beg[i]; beg[i]=beg[i-1]; beg[i-1]=swap;
				swap=end[i]; end[i]=end[i-1]; end[i-1]=swap; 
			}
		}
		else {i--;}
	}
}
