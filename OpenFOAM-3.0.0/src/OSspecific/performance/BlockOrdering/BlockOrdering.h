/*#########################
	将数据结构进行到底

	MLB means Multilevel_Blocking
#########################*/

#ifndef BLOCKORDERING_H
#define BLOCKORDERING_H

#include "stdio.h"
#include "metis.h"
#include "extensibleLabelArray.h"
#include "extensibleScalarArray.h"
#include "timer.h"

#ifdef __cplusplus
extern "C"
{
#endif

#define CERR(...) \
{ \
	printf("***Error: at "); \
	printf("%s",__FILE__); \
	printf("+%d:",__LINE__); \
	printf("\n\t"); \
	printf("in function \"%s\": ", __FUNCTION__); \
	printf(__VA_ARGS__); \
}


#define forprt(array, n) \
{\
	printf(#array);\
	printf(":{");\
	LABEL i;\
	for(i=0; i<n; i++)\
	  printf(" %d", (LABEL)(array[i]));\
	printf("}\n");\
}

#define startTime() \
	LABEL printTime_start = getSystemTime()

#define printTime(tag) \
{ \
	printf("=======================\n");\
	printf(#tag);\
	printf(": %fs\n", getSystemTime()-printTime_start); \
	printTime_start = getSystemTime(); \
	printf("=======================\n");\
}


typedef struct struct_MLB_graph
{
    LABEL* owner;	// cell owns the edge starts from "0" 
 	LABEL* neighbor;	// cell adjoins to the edge
	LABEL* cellWeights;
	LABEL* edgeWeights;
 	LABEL cellNum;    // number of the cells
 	LABEL edgeNum;	// number of the edges
} MLB_graph;

void MLB_Multilevel_ordering
(
    MLB_graph graph,
	LABEL levels,		// number of levels
	LABEL* blockNums,	// number of blocks for each level
	// blockStarts: Three-LABEL element array.
	// The first is block-row index, and second block-column.
	// The third is the start edge index for each block.
	// Only upper triagle stored.
	LABEL* blockStarts,
	LABEL* cellStarts, // start cell index for each block
	// postCellOrder & postEdgeOrder:
	// Index mirror from the old order to the new one.
	// The position of the element corresponds to the old order,
	// and the element value the new one.
	LABEL* postCellOrder,
	LABEL* postEdgeOrder
);

void MLB_ordering
(
    MLB_graph graph,
	LABEL blockNum,	// number of blocks for each level
    // postCellOrder:
    // Index mirror from the old order to the new one.
    // The position of the element corresponds to the old order,
    // and the element value the new one.
    LABEL* postCellOrder,	// starts from zero
    LABEL* cellStarts	// cells in each block
);

// reorder the float datas arrays with the index mirror
// generated by multi_block_ordering
void MLB_postSCALAR
(
    LABEL* postOrder,
    SCALAR*	dataArray,
    LABEL length,
    LABEL dim
);

void MLB_postLabel
(
    LABEL* postOrder,
    LABEL*	dataArray,
    LABEL length,
    LABEL dim
);

// reorder the integer datas arrays with the index mirror
// generated by multi_block_ordering
void MLB_metis_decompose
(
    idx_t cellNum,
    idx_t edgeNum,
    idx_t* adj,
    idx_t* neighbor,
    idx_t* cellWeight,
    idx_t* edgeWeight,
    idx_t blockNum,
    idx_t* options,
    idx_t* edgeCut,
    idx_t* blockCells,
    char* method
);

void MLB_generateCellID
(
    LABEL* owner,
    LABEL* neighbor,
    LABEL* cellID,
    LABEL cellNum,
    LABEL edgeNum
);

void MLB_offsetEdges
(
    LABEL* owner,
    LABEL* neighbor,
    LABEL* cellID,
    LABEL* ownerNorm,
    LABEL* neighborNorm,
    LABEL cellNum,
    LABEL edgeNum
);

void MLB_constructMetisCSR
(
    LABEL* owner,
    LABEL* neighbor,
    LABEL* edegWeight,
    LABEL* xadj,
    LABEL* adjncy,
    LABEL* edge_wgt,
    LABEL cellNum,
    LABEL edgeNum
);

LABEL MLB_find(LABEL id, LABEL* array, LABEL num);

void MLB_quickSort(int *arr, int elements);

#ifdef __cplusplus
}
#endif

#endif // BLOCKORDERNG_H
